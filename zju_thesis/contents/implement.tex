% !TEX root = ../main.tex

\chapter{算法实现}
CUDA是由英伟达推出的利用GPU进行通用计算的技术。该技术提供了方便易用的API，允许用户利用GPU强大的并行计算能力来加速算法，能得到了学术界和工业界的广泛应用。光滑自由变形\cite{Cui15}基于CUDA实现。大概获得了100多倍的加速。但是CUDA只能的在英伟达的硬件设备上运行，这大大限制了光滑自由变形的通用性，光滑自由变形不仅无法应用在其它的桌面平台的GPU（AMD、Intel核显）中，也无法在移动平台中运行。而后者由于计算资源有限，反而更加依赖GPU加速算法。

本文算法基于光滑自由变形\cite{Cui15}，所以在变形、微调变形结果、绘制时所用的算法都与光滑自由变形相同。但是为了使算法更加通用，我们采用了OpenGL的Comput Shader实现本文算法。


在具体实现过程中，变形、微调三角贝赛尔曲面片（变形结果）的控制顶点，细分三角贝赛尔曲面片均采用和光滑自由变形相同的算法。不仅如此，我们还将光滑自由变形中CPU实现了部分——分割过程，实现在了GPU中，使整个算法都在GPU中完成。


\tikzstyle{GPU} = [rectangle, draw, fill=blue!15, 
    text width=15em, text centered, rounded corners, minimum height=3em]

\tikzstyle{CPU} = [rectangle, draw, fill=red!15, 
    text width=15em, text centered, rounded corners, minimum height=3em]
\tikzstyle{line} = [draw, thick, ->, >= stealth]

\begin{figure}
	\centering
    \begin{tikzpicture}[node distance = 2cm, auto]
        % Place nodes
        \node [CPU] (read) {输入多边形网格模型};
        \node [CPU, below of=read] (initspace) {初始化B样条空间，并将模型嵌入其中};
        \node [GPU, below of=initspace] (split) {三角化多边形，并用三角形均匀剖分算法分割三角形};
        \node [GPU, below of=split] (pntriangle) {求子三角面片的PN-Triangle，用以调整变形结果};
        \node [GPU, below of=pntriangle] (sample) {根据控制顶点，计算采样点的位置与法向};
        \node [GPU, below of=sample] (deformation) {用带约束的拟合的方法，计算出三角贝赛尔曲面片和法向量场的控制顶点};
        \node [GPU, below of=deformation] (adjust) {用法向信息和PN-Triangle信息调整上一步得到的控制顶点};
        \node [GPU, below of=adjust] (tess) {细分变形结果并绘制};
        \node [CPU, right=2em of deformation] (edit) {用户编辑控制顶点};

        % Draw edges
        \path [line] (read) -- (initspace);
        \path [line] (initspace) -- (split);
        \path [line] (split) -- (pntriangle);
        \path [line] (pntriangle) -- (sample);
        \path [line] (sample) -- (deformation);
        \path [line] (deformation) -- (adjust);
        \path [line] (adjust) -- (tess);
        \path [line] (tess) -| (edit);
        \path [line] (edit) |- (sample);
    \end{tikzpicture}
    \caption{本文算法流程图}\label{fig:algorithm_sffd}
\end{figure}



\section{三角均匀剖分算法的GPU实现}
将其中较复杂的部分从算法中抽取出来对三角形均匀分割算法进行了解耦，使计算分割方案与分割三角形在不同的阶段进行。其中计算分割方案实现较为复杂

第\autoref{clip_algorithm}节中的算法是一个递归调用的算法，且算法中还有很多判断分支和特殊情况。这种算法不适合用GPU实现。所以，我们采用以空间换取时间并控制复杂度的策略，先预计算了不同边长的三角形的分割方案，并将分割方案以三角面片各边被分割的段数，即$\{\lceil len_i/l \rceil\}^{2}_{i=0}$为索引储存在一张表中，分割方案由分割点的重心坐标与子三角形的连接情况表示。当Compute Shader需要分割三角面片时，先计算$\{\lceil len_i/l \rceil\}^{2}_{i=0}$，再以此为索引找出合适的分割方案，进而完成三角形的分割。

在Compute Shader分割三角形时，以分割点的重心坐标与三角面片的顶点位置为输入，可以用矩阵乘法直接求出分割点的位置。这些点的连接关系也由分割方案给出。上述过程没有递归，且分支较少，很适合GPU实现。

但是在该算法中，不同的三角形，其索引值$\{\lceil len_i/l \rceil\}^{2}_{i=0}$可能相同。也就是说不同的三角形，只要其索引值$\{\lceil len_i/l \rceil\}^{2}_{i=0}$相同，那么它们的分割方案都相同，由连长为$\{\lceil len_i/l \rceil * l\}^{2}_{i=0}$的三角面片预计算确定。虽然这会在一定程度上带来子三角形质量的下降，但考虑到其对算法性能的提升，这一方法仍是值得采用的。\textcolor{red}{此处需要具体数据}



